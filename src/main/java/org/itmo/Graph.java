package org.itmo;

import org.jetbrains.annotations.NotNull;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerArray;

class Graph {
    private final int V;
    private AtomicInteger counter;
    private final ArrayList<Integer>[] adjList;

    @SuppressWarnings("unchecked")
    Graph(int vertices) {
        this.V = vertices;
        this.counter = new AtomicInteger(0);
        adjList = new ArrayList[vertices];
        for (int i = 0; i < vertices; ++i) {
            adjList[i] = new ArrayList<>();
        }
    }

    void addEdge(int src, int dest) {
        if (!adjList[src].contains(dest)) {
            adjList[src].add(dest);
        }
    }

    public AtomicInteger getCounter() {
        return counter;
    }

    public void cleanCounter() {
        counter = new AtomicInteger(0);
    }

    void scanLevel(
            int vertex,
            int threadsAvailable,
            AtomicIntegerArray visited,
            ExecutorService executor,
            ConcurrentLinkedQueue<Integer> nextQueue
    ) {
        List<Integer> neighbors = adjList[vertex];

        if (neighbors.size() < threadsAvailable * 10) {
            for (int n : neighbors) {
                if (visited.compareAndSet(n, 0, 1)) {
                    counter.incrementAndGet();
                    nextQueue.add(n);
                }
            }
        }
        else {
            int chunkSize = neighbors.size() / threadsAvailable + 1;
            CountDownLatch latch = new CountDownLatch(threadsAvailable);
            List<Integer>[] localResultQueues = new LinkedList[threadsAvailable];
            Arrays.setAll(localResultQueues, i -> new LinkedList<Integer>());

            for (int t = 0; t < threadsAvailable; t++) {
                int start = t * chunkSize;
                int end = Math.min(neighbors.size(), (t + 1) * chunkSize);
                int finalT = t;

                executor.execute(() -> {
                    try {
                        for (int i = start; i < end; i++) {
                            int n = neighbors.get(i);
                            if (visited.compareAndSet(n, 0, 1)) {
                                counter.incrementAndGet();
                                localResultQueues[finalT].add(n);
                            }
                        }
                    } finally {
                        latch.countDown();
                    }
                });
            }

            try {
                latch.await();
                for (List<Integer> localResultQueue : localResultQueues) {
                    nextQueue.addAll(localResultQueue);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    void parallelBFS(int startVertex) {
        parallelBFS(startVertex, Math.min(Runtime.getRuntime().availableProcessors(), 4));
    }

    void parallelBFS(int startVertex, int threadsAvailable) {
        AtomicIntegerArray visited = new AtomicIntegerArray(V);
        ConcurrentLinkedQueue<Integer> levelsQueue = new ConcurrentLinkedQueue<Integer>();
        ExecutorService executor = Executors.newFixedThreadPool(threadsAvailable);

        levelsQueue.add(startVertex);

        try {
            while ( ! levelsQueue.isEmpty()) {
                ConcurrentLinkedQueue<Integer> nextQueue = new ConcurrentLinkedQueue<Integer>();
                Integer actualVertex;
                while ((actualVertex = levelsQueue.poll()) != null) {
                    this.scanLevel(actualVertex, threadsAvailable, visited, executor, nextQueue);
                }
                levelsQueue = nextQueue;
            }
        }
        finally {
            executor.shutdown();
        }
    }

    //Generated by ChatGPT
    void bfs(int startVertex) {
        boolean[] visited = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);
        counter.incrementAndGet();

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList[startVertex]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                    counter.incrementAndGet();
                }
            }
        }
    }

}
